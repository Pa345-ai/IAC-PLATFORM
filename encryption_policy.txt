package terraform.encryption_enforcement

import future.keywords.contains
import future.keywords.if
import future.keywords.in

# METADATA
# title: Encryption at Rest and In Transit Enforcement
# description: Mandates encryption for all data storage per PCI-DSS 3.4 and NIST 800-53 SC-28
# custom:
#   severity: CRITICAL
#   compliance: ["PCI-DSS-3.4", "NIST-800-53-SC-28", "SOC2-CC6.1"]

# S3 Buckets must have encryption enabled
deny[msg] {
    resource := input.resource_changes[_]
    resource.type == "aws_s3_bucket"
    resource.change.actions[_] == "create"
    
    # Check if encryption configuration exists
    not has_s3_encryption(resource)
    
    msg := sprintf(
        "CRITICAL: S3 bucket '%s' does not have server-side encryption configured. Required by PCI-DSS 3.4",
        [resource.name]
    )
}

# S3 encryption must use KMS (not just AES256)
deny[msg] {
    resource := input.resource_changes[_]
    resource.type == "aws_s3_bucket_server_side_encryption_configuration"
    
    rule := resource.change.after.rule[_]
    algo := rule.apply_server_side_encryption_by_default.sse_algorithm
    
    algo != "aws:kms"
    
    msg := sprintf(
        "CRITICAL: S3 bucket encryption for '%s' uses '%s' instead of KMS. KMS required for key rotation and audit.",
        [resource.name, algo]
    )
}

# RDS instances must have encryption enabled
deny[msg] {
    resource := input.resource_changes[_]
    resource.type == "aws_db_instance"
    resource.change.actions[_] == "create"
    
    encrypted := object.get(resource.change.after, "storage_encrypted", false)
    not encrypted
    
    msg := sprintf(
        "CRITICAL: RDS instance '%s' does not have storage encryption enabled. Required by PCI-DSS 3.4",
        [resource.name]
    )
}

# RDS must use customer-managed KMS keys
deny[msg] {
    resource := input.resource_changes[_]
    resource.type == "aws_db_instance"
    
    encrypted := object.get(resource.change.after, "storage_encrypted", false)
    encrypted == true
    
    kms_key := object.get(resource.change.after, "kms_key_id", "")
    kms_key == ""
    
    msg := sprintf(
        "CRITICAL: RDS instance '%s' uses default encryption. Must specify customer-managed KMS key.",
        [resource.name]
    )
}

# EBS volumes must be encrypted
deny[msg] {
    resource := input.resource_changes[_]
    resource.type == "aws_ebs_volume"
    resource.change.actions[_] == "create"
    
    encrypted := object.get(resource.change.after, "encrypted", false)
    not encrypted
    
    msg := sprintf(
        "CRITICAL: EBS volume '%s' is not encrypted. All block storage must be encrypted.",
        [resource.name]
    )
}

# DynamoDB tables must have encryption enabled
deny[msg] {
    resource := input.resource_changes[_]
    resource.type == "aws_dynamodb_table"
    resource.change.actions[_] == "create"
    
    not has_dynamodb_encryption(resource)
    
    msg := sprintf(
        "CRITICAL: DynamoDB table '%s' does not have encryption enabled. Required by compliance.",
        [resource.name]
    )
}

# EFS file systems must be encrypted
deny[msg] {
    resource := input.resource_changes[_]
    resource.type == "aws_efs_file_system"
    resource.change.actions[_] == "create"
    
    encrypted := object.get(resource.change.after, "encrypted", false)
    not encrypted
    
    msg := sprintf(
        "CRITICAL: EFS file system '%s' is not encrypted. All file systems must be encrypted.",
        [resource.name]
    )
}

# Redshift clusters must be encrypted
deny[msg] {
    resource := input.resource_changes[_]
    resource.type == "aws_redshift_cluster"
    resource.change.actions[_] == "create"
    
    encrypted := object.get(resource.change.after, "encrypted", false)
    not encrypted
    
    msg := sprintf(
        "CRITICAL: Redshift cluster '%s' is not encrypted. Data warehouse must be encrypted.",
        [resource.name]
    )
}

# SNS topics must be encrypted
deny[msg] {
    resource := input.resource_changes[_]
    resource.type == "aws_sns_topic"
    resource.change.actions[_] == "create"
    
    kms_key := object.get(resource.change.after, "kms_master_key_id", "")
    kms_key == ""
    
    msg := sprintf(
        "CRITICAL: SNS topic '%s' is not encrypted with KMS. Message encryption required.",
        [resource.name]
    )
}

# SQS queues must be encrypted
deny[msg] {
    resource := input.resource_changes[_]
    resource.type == "aws_sqs_queue"
    resource.change.actions[_] == "create"
    
    kms_key := object.get(resource.change.after, "kms_master_key_id", "")
    kms_key == ""
    
    msg := sprintf(
        "CRITICAL: SQS queue '%s' is not encrypted with KMS. Queue encryption required.",
        [resource.name]
    )
}

# KMS keys must have rotation enabled
deny[msg] {
    resource := input.resource_changes[_]
    resource.type == "aws_kms_key"
    resource.change.actions[_] == "create"
    
    rotation := object.get(resource.change.after, "enable_key_rotation", false)
    not rotation
    
    msg := sprintf(
        "CRITICAL: KMS key '%s' does not have automatic rotation enabled. Required by PCI-DSS 3.6.4",
        [resource.name]
    )
}

# Load balancers must use HTTPS
deny[msg] {
    resource := input.resource_changes[_]
    resource.type == "aws_lb_listener"
    resource.change.actions[_] == "create"
    
    protocol := resource.change.after.protocol
    protocol == "HTTP"
    
    msg := sprintf(
        "CRITICAL: Load balancer listener '%s' uses HTTP. HTTPS required for data in transit.",
        [resource.name]
    )
}

# ElastiCache must have encryption in transit
deny[msg] {
    resource := input.resource_changes[_]
    resource.type == "aws_elasticache_replication_group"
    resource.change.actions[_] == "create"
    
    transit_encryption := object.get(resource.change.after, "transit_encryption_enabled", false)
    not transit_encryption
    
    msg := sprintf(
        "CRITICAL: ElastiCache '%s' does not have transit encryption enabled.",
        [resource.name]
    )
}

# ElastiCache must have encryption at rest
deny[msg] {
    resource := input.resource_changes[_]
    resource.type == "aws_elasticache_replication_group"
    resource.change.actions[_] == "create"
    
    at_rest_encryption := object.get(resource.change.after, "at_rest_encryption_enabled", false)
    not at_rest_encryption
    
    msg := sprintf(
        "CRITICAL: ElastiCache '%s' does not have at-rest encryption enabled.",
        [resource.name]
    )
}

# Secrets Manager secrets must be encrypted with KMS
warn[msg] {
    resource := input.resource_changes[_]
    resource.type == "aws_secretsmanager_secret"
    
    kms_key := object.get(resource.change.after, "kms_key_id", "")
    kms_key == ""
    
    msg := sprintf(
        "WARNING: Secrets Manager secret '%s' uses default encryption. Consider customer-managed KMS key.",
        [resource.name]
    )
}

# Helper functions
has_s3_encryption(resource) {
    # This would be checked via aws_s3_bucket_server_side_encryption_configuration resource
    # Since Terraform AWS provider v4+, this is a separate resource
    true
}

has_dynamodb_encryption(resource) {
    encryption := object.get(resource.change.after, "server_side_encryption", {})
    count(encryption) > 0
}

# Compliance summary
encryption_compliance_report[result] {
    total_storage_resources := count([r | 
        r := input.resource_changes[_]; 
        r.type in storage_resource_types
    ])
    
    result := {
        "total_storage_resources": total_storage_resources,
        "policy": "Encryption Enforcement",
        "encryption_required": "AES-256 with KMS",
        "key_rotation": "Mandatory",
        "compliance_frameworks": ["PCI-DSS-3.4", "NIST-800-53-SC-28", "SOC2-CC6.1"]
    }
}

storage_resource_types := {
    "aws_s3_bucket",
    "aws_db_instance",
    "aws_ebs_volume",
    "aws_efs_file_system",
    "aws_dynamodb_table",
    "aws_redshift_cluster"
}