# environments/prod/main.tf
# Production Environment - Maximum Security and High Availability

terraform {
  required_version = ">= 1.6.0"
  
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

locals {
  environment = "prod"
  
  common_tags = {
    Environment = local.environment
    ManagedBy   = "terraform"
    Repository  = "sovereign-cloud-archive"
    CostCenter  = "production"
    Compliance  = "pci-dss-nist-soc2"
    Criticality = "mission-critical"
  }
}

# Data Sources
data "terraform_remote_state" "global_networking" {
  backend = "s3"
  
  config = {
    bucket = var.tfstate_bucket
    key    = "global/networking/terraform.tfstate"
    region = var.aws_region
  }
}

data "terraform_remote_state" "global_iam" {
  backend = "s3"
  
  config = {
    bucket = var.tfstate_bucket
    key    = "global/iam/terraform.tfstate"
    region = var.aws_region
  }
}

data "aws_caller_identity" "current" {}
data "aws_region" "current" {}

################################################################################
# VPC and Networking
################################################################################

module "vpc" {
  source = "../../modules/networking/vpc"
  
  environment             = local.environment
  vpc_cidr                = var.vpc_cidr
  multi_az                = true
  enable_flow_logs        = true
  enable_vpc_endpoints    = true
  flow_log_retention_days = 365  # 1 year for production
  kms_key_arn            = module.kms.encryption_key_arn
  
  tags = merge(local.common_tags, {
    Name = "${local.environment}-vpc"
  })
}

# Connect to Transit Gateway
resource "aws_ec2_transit_gateway_vpc_attachment" "prod" {
  subnet_ids         = module.vpc.private_subnet_ids
  transit_gateway_id = data.terraform_remote_state.global_networking.outputs.transit_gateway_id
  vpc_id             = module.vpc.vpc_id
  
  transit_gateway_default_route_table_association = false
  transit_gateway_default_route_table_propagation = false
  
  dns_support  = "enable"
  ipv6_support = "disable"
  
  tags = merge(local.common_tags, {
    Name = "${local.environment}-tgw-attachment"
  })
}

resource "aws_ec2_transit_gateway_route_table_association" "prod" {
  transit_gateway_attachment_id  = aws_ec2_transit_gateway_vpc_attachment.prod.id
  transit_gateway_route_table_id = data.terraform_remote_state.global_networking.outputs.production_route_table_id
}

################################################################################
# KMS Encryption Keys
################################################################################

module "kms" {
  source = "../../modules/security/kms"
  
  environment         = local.environment
  key_name            = "prod-master-key"
  enable_key_rotation = true
  deletion_window     = 30
  
  key_administrators = [
    data.terraform_remote_state.global_iam.outputs.admin_role_arn
  ]
  
  key_users = [
    data.terraform_remote_state.global_iam.outputs.eks_cluster_role_arn,
    "arn:aws:iam::${data.aws_caller_identity.current.account_id}:root"
  ]
  
  tags = local.common_tags
}

################################################################################
# EKS Cluster (Hardened Kubernetes)
################################################################################

module "eks" {
  source = "../../modules/compute/eks"
  
  environment    = local.environment
  cluster_name   = "${local.environment}-eks-cluster"
  cluster_version = var.eks_cluster_version
  
  vpc_id              = module.vpc.vpc_id
  subnet_ids          = module.vpc.private_subnet_ids
  control_plane_subnet_ids = module.vpc.private_subnet_ids
  
  cluster_endpoint_private_access = true
  cluster_endpoint_public_access  = false  # Production: No public access
  
  # Encryption
  cluster_encryption_config = {
    provider_key_arn = module.kms.encryption_key_arn
    resources        = ["secrets"]
  }
  
  # Logging
  cluster_enabled_log_types = [
    "api",
    "audit",
    "authenticator",
    "controllerManager",
    "scheduler"
  ]
  
  # Node Groups
  node_groups = {
    application = {
      desired_size   = 3
      min_size       = 3
      max_size       = 10
      instance_types = ["m5.xlarge"]
      disk_size      = 100
      disk_encrypted = true
      disk_kms_key_id = module.kms.encryption_key_arn
      
      labels = {
        role = "application"
      }
      
      taints = []
    }
    
    monitoring = {
      desired_size   = 2
      min_size       = 2
      max_size       = 4
      instance_types = ["m5.large"]
      disk_size      = 50
      disk_encrypted = true
      disk_kms_key_id = module.kms.encryption_key_arn
      
      labels = {
        role = "monitoring"
      }
      
      taints = [{
        key    = "monitoring"
        value  = "true"
        effect = "NoSchedule"
      }]
    }
  }
  
  # IAM Roles
  cluster_role_arn           = data.terraform_remote_state.global_iam.outputs.eks_cluster_role_arn
  node_role_arn              = data.terraform_remote_state.global_iam.outputs.eks_node_role_arn
  node_instance_profile_name = data.terraform_remote_state.global_iam.outputs.eks_node_instance_profile
  
  tags = local.common_tags
}

################################################################################
# RDS Database (Multi-AZ with Read Replicas)
################################################################################

module "rds" {
  source = "../../modules/data/rds"
  
  environment = local.environment
  identifier  = "${local.environment}-primary-db"
  
  # Engine
  engine               = var.rds_engine
  engine_version       = var.rds_engine_version
  instance_class       = var.rds_instance_class
  allocated_storage    = 1000  # GB
  max_allocated_storage = 5000  # Auto-scaling up to 5TB
  storage_encrypted    = true
  kms_key_id          = module.kms.encryption_key_arn
  
  # High Availability
  multi_az                   = true
  backup_retention_period    = 35  # 35 days for production
  backup_window              = "03:00-04:00"
  maintenance_window         = "sun:04:00-sun:05:00"
  enabled_cloudwatch_logs_exports = ["error", "general", "slowquery"]
  
  # Network
  vpc_id             = module.vpc.vpc_id
  subnet_ids         = module.vpc.data_subnet_ids
  allowed_cidr_blocks = module.vpc.private_subnet_cidrs
  
  # Monitoring
  performance_insights_enabled    = true
  performance_insights_kms_key_id = module.kms.encryption_key_arn
  monitoring_interval             = 60
  monitoring_role_arn             = data.terraform_remote_state.global_iam.outputs.rds_monitoring_role_arn
  
  # Parameters
  family = var.rds_parameter_family
  parameters = [
    {
      name  = "log_connections"
      value = "1"
    },
    {
      name  = "log_disconnections"
      value = "1"
    },
    {
      name  = "log_statement"
      value = "all"
    }
  ]
  
  tags = local.common_tags
}

# Read Replica for Reporting Workloads
module "rds_read_replica" {
  source = "../../modules/data/rds"
  
  environment = local.environment
  identifier  = "${local.environment}-read-replica"
  
  replicate_source_db = module.rds.db_instance_id
  
  instance_class    = var.rds_instance_class
  storage_encrypted = true
  kms_key_id       = module.kms.encryption_key_arn
  
  vpc_id             = module.vpc.vpc_id
  subnet_ids         = module.vpc.data_subnet_ids
  allowed_cidr_blocks = module.vpc.private_subnet_cidrs
  
  backup_retention_period = 7  # Read replica can have shorter retention
  
  tags = merge(local.common_tags, {
    Purpose = "ReadReplica"
    Workload = "Reporting"
  })
}

# DR Read Replica in Secondary Region
module "rds_dr_replica" {
  source = "../../modules/data/rds"
  
  providers = {
    aws = aws.dr_region
  }
  
  environment = local.environment
  identifier  = "${local.environment}-dr-replica"
  
  replicate_source_db = module.rds.db_instance_arn
  
  instance_class    = var.rds_instance_class
  storage_encrypted = true
  
  vpc_id             = var.dr_vpc_id
  subnet_ids         = var.dr_subnet_ids
  allowed_cidr_blocks = [var.dr_vpc_cidr]
  
  backup_retention_period = 35
  
  tags = merge(local.common_tags, {
    Purpose = "DisasterRecovery"
    Region  = var.dr_region
  })
}

################################################################################
# Application Load Balancer
################################################################################

resource "aws_lb" "application" {
  name               = "${local.environment}-app-alb"
  internal           = false
  load_balancer_type = "application"
  security_groups    = [aws_security_group.alb.id]
  subnets            = module.vpc.public_subnet_ids
  
  enable_deletion_protection = true
  enable_http2              = true
  enable_cross_zone_load_balancing = true
  
  drop_invalid_header_fields = true
  
  access_logs {
    bucket  = aws_s3_bucket.alb_logs.id
    prefix  = "alb"
    enabled = true
  }
  
  tags = local.common_tags
}

resource "aws_lb_listener" "https" {
  load_balancer_arn = aws_lb.application.arn
  port              = "443"
  protocol          = "HTTPS"
  ssl_policy        = "ELBSecurityPolicy-TLS13-1-2-2021-06"
  certificate_arn   = var.acm_certificate_arn
  
  default_action {
    type = "fixed-response"
    
    fixed_response {
      content_type = "text/plain"
      message_body = "Access Denied"
      status_code  = "403"
    }
  }
}

# Redirect HTTP to HTTPS
resource "aws_lb_listener" "http_redirect" {
  load_balancer_arn = aws_lb.application.arn
  port              = "80"
  protocol          = "HTTP"
  
  default_action {
    type = "redirect"
    
    redirect {
      port        = "443"
      protocol    = "HTTPS"
      status_code = "HTTP_301"
    }
  }
}

resource "aws_security_group" "alb" {
  name_prefix = "${local.environment}-alb-"
  description = "Security group for application load balancer"
  vpc_id      = module.vpc.vpc_id
  
  ingress {
    description = "HTTPS from internet"
    from_port   = 443
    to_port     = 443
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }
  
  ingress {
    description = "HTTP from internet (redirect to HTTPS)"
    from_port   = 80
    to_port     = 80
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }
  
  egress {
    description = "All outbound traffic"
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }
  
  tags = local.common_tags
  
  lifecycle {
    create_before_destroy = true
  }
}

# ALB Logs Bucket
resource "aws_s3_bucket" "alb_logs" {
  bucket = "${local.environment}-alb-logs-${data.aws_caller_identity.current.account_id}"
  
  tags = merge(local.common_tags, {
    Purpose = "LoadBalancerLogs"
  })
}

resource "aws_s3_bucket_server_side_encryption_configuration" "alb_logs" {
  bucket = aws_s3_bucket.alb_logs.id
  
  rule {
    apply_server_side_encryption_by_default {
      sse_algorithm = "AES256"
    }
  }
}

resource "aws_s3_bucket_public_access_block" "alb_logs" {
  bucket = aws_s3_bucket.alb_logs.id
  
  block_public_acls       = true
  block_public_policy     = true
  ignore_public_acls      = true
  restrict_public_buckets = true
}

resource "aws_s3_bucket_policy" "alb_logs" {
  bucket = aws_s3_bucket.alb_logs.id
  
  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Principal = {
          AWS = "arn:aws:iam::${var.elb_service_account_id}:root"
        }
        Action   = "s3:PutObject"
        Resource = "${aws_s3_bucket.alb_logs.arn}/*"
      }
    ]
  })
}

################################################################################
# WAF for Application Protection
################################################################################

resource "aws_wafv2_web_acl" "main" {
  name  = "${local.environment}-web-acl"
  scope = "REGIONAL"
  
  default_action {
    allow {}
  }
  
  # AWS Managed Rules
  rule {
    name     = "AWSManagedRulesCommonRuleSet"
    priority = 1
    
    override_action {
      none {}
    }
    
    statement {
      managed_rule_group_statement {
        vendor_name = "AWS"
        name        = "AWSManagedRulesCommonRuleSet"
      }
    }
    
    visibility_config {
      cloudwatch_metrics_enabled = true
      metric_name                = "AWSManagedRulesCommonRuleSetMetric"
      sampled_requests_enabled   = true
    }
  }
  
  rule {
    name     = "AWSManagedRulesKnownBadInputsRuleSet"
    priority = 2
    
    override_action {
      none {}
    }
    
    statement {
      managed_rule_group_statement {
        vendor_name = "AWS"
        name        = "AWSManagedRulesKnownBadInputsRuleSet"
      }
    }
    
    visibility_config {
      cloudwatch_metrics_enabled = true
      metric_name                = "AWSManagedRulesKnownBadInputsRuleSetMetric"
      sampled_requests_enabled   = true
    }
  }
  
  # Rate Limiting
  rule {
    name     = "RateLimitRule"
    priority = 3
    
    action {
      block {}
    }
    
    statement {
      rate_based_statement {
        limit              = 2000
        aggregate_key_type = "IP"
      }
    }
    
    visibility_config {
      cloudwatch_metrics_enabled = true
      metric_name                = "RateLimitRule"
      sampled_requests_enabled   = true
    }
  }
  
  visibility_config {
    cloudwatch_metrics_enabled = true
    metric_name                = "${local.environment}-web-acl"
    sampled_requests_enabled   = true
  }
  
  tags = local.common_tags
}

resource "aws_wafv2_web_acl_association" "alb" {
  resource_arn = aws_lb.application.arn
  web_acl_arn  = aws_wafv2_web_acl.main.arn
}

################################################################################
# Outputs
################################################################################

output "vpc_id" {
  value = module.vpc.vpc_id
}

output "eks_cluster_endpoint" {
  value     = module.eks.cluster_endpoint
  sensitive = true
}

output "rds_endpoint" {
  value     = module.rds.db_instance_endpoint
  sensitive = true
}

output "alb_dns_name" {
  value = aws_lb.application.dns_name
}